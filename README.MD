### задание с презентации

1. Створіть нову базу даних studentDB.
2. У цій базі створіть колекцію assignments.
3. Додайте до колекції assignments п'ять документів, кожен з яких містить поля: name (ім'я студента), subject (предмет), score (бал).
4. Виконайте запит, щоб знайти всі документи, де score більше 80.
5. Оновіть один з документів, збільшивши score на 5 балів для студента, який має менше 85 балів.
6. Видаліть документ для студента, який має найнижчий бал.
7. Використайте команду find() з проекцією, щоб вивести тільки ім'я та бал студента.
8. Використовуючи колекцію assignments, напишіть агрегаційний запит, який групує документи за предметом та обчислює середній бал за кожним предметом.
9. Додайте до агрегації етап, що фільтрує результати для виведення тільки тих предметів, де середній бал вище 75.

---

### адаптированное

1. Створіть нову базу даних teaDB.
2. У цій базі створіть колекцію reviews.
3. Додайте до колекції reviews п'ять документів, кожен з яких містить поля: teaName (назва чаю), origin (походження чаю), rating (оцінка смаку).
4. Виконайте запит, щоб знайти всі чаї, у яких rating більше 80.
5. Оновіть один з документів, збільшивши rating на 5 балів для чаю, який має менше 85 балів.
6. Видаліть документ із чаєм, який має найнижчу оцінку.
7. Використайте команду find() з проекцією, щоб вивести тільки назву та оцінку чаю.
8. Використовуючи колекцію reviews, напишіть агрегаційний запит, який групує документи за полем origin і обчислює середню оцінку чаю з кожного регіону.
9. Додайте до агрегації етап, що фільтрує результати для виведення тільки тих регіонів, де середній rating вищий за 75.

---

### дальше с лмс доп задания (2)

1. тоже самое что в 8
2. тоже самое что в 9

---

### дальше с лмс доп задания (3)

12. Створіть унікальний індекс для поля teaName у колекції reviews для запобігання дублювання назв чаїв.
13. Виконайте запит пошуку, який використовує цей індекс, для вибірки документів, де teaName починається на літеру 'O'.
14. Аналізуйте час виконання запиту до та після створення індексу, використовуючи explain() для демонстрації ефективності індексу.